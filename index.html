<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>SLIME DERBY</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#0f0f23">
    <link rel="apple-touch-icon" href="icons/icon-192.png">

    <!-- Open Graph Meta Tags -->
    <meta property="og:title" content="SLIME DERBY üéÆ" />
    <meta property="og:description" content="Í∑ÄÏó¨Ïö¥ Ïä¨ÎùºÏûÑÎì§Ïùò Î†àÏù¥Ïã± Í≤åÏûÑ! Ïä¨ÎùºÏûÑÏùÑ ÏÑ†ÌÉùÌï¥ÏÑú Í≤ΩÏ£ºÏóêÏÑú Ïö∞ÏäπÌïòÏÑ∏Ïöî üèÜ" />
    <meta property="og:type" content="website" />
    <meta property="og:image" content="https://honux77.github.io/slime-derby/og-image.png" />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />
    <meta property="og:image:alt" content="SLIME DERBY - Ïä¨ÎùºÏûÑ Î†àÏù¥Ïã± Í≤åÏûÑ" />
    <meta name="description" content="Í∑ÄÏó¨Ïö¥ Ïä¨ÎùºÏûÑÎì§Ïùò Î†àÏù¥Ïã± Í≤åÏûÑ! Ïä¨ÎùºÏûÑÏùÑ ÏÑ†ÌÉùÌï¥ÏÑú Í≤ΩÏ£ºÏóêÏÑú Ïö∞ÏäπÌïòÏÑ∏Ïöî üèÜ" />
    
    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="SLIME DERBY üéÆ" />
    <meta name="twitter:description" content="Í∑ÄÏó¨Ïö¥ Ïä¨ÎùºÏûÑÎì§Ïùò Î†àÏù¥Ïã± Í≤åÏûÑ! Ïä¨ÎùºÏûÑÏùÑ ÏÑ†ÌÉùÌï¥ÏÑú Í≤ΩÏ£ºÏóêÏÑú Ïö∞ÏäπÌïòÏÑ∏Ïöî üèÜ" />
    <meta name="twitter:image" content="https://honux77.github.io/slime-derby/og-image.png" />
    
    <link href="https://unpkg.com/nes.css@latest/css/nes.min.css" rel="stylesheet" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #0f0f23;
            --panel: #0a0a1a;
            --surface: #141428;
            --white: #fcfcfc;
            --green: #58d854;
            --yellow: #ffd700;
            --gray: #888;
            --border: #333;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        /* Override NES.css global resets */
        label { display: inline; margin-bottom: 0; }
        body {
            font-family: 'Press Start 2P', monospace;
            background: var(--bg);
            color: var(--white);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            padding: 0;
        }
        #app {
            width: 100vw;
            height: 100vh;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .screen {
            display: none; position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            flex-direction: column;
            align-items: center; justify-content: center;
            padding: 20px;
            overflow-y: auto;
        }
        .screen.active { display: flex; }

        /* ===== Title ===== */
        #title-screen h1 {
            font-size: clamp(24px, 5vw, 40px);
            color: var(--green);
            text-shadow: 3px 3px 0 #1a5a1a, 6px 6px 0 rgba(0,0,0,0.4);
            margin-bottom: 12px; text-align: center;
            animation: pulse 2s ease-in-out infinite;
        }
        #title-screen .subtitle {
            font-size: clamp(8px, 1.8vw, 12px);
            color: var(--gray); margin-bottom: 40px;
        }
        @keyframes pulse {
            0%,100% { transform: scale(1); }
            50% { transform: scale(1.04); }
        }
        .title-slime-container {
            position: relative; width: 100px; height: 90px;
            margin-bottom: 30px;
        }
        .title-slime {
            width: 80px; height: 60px;
            background: var(--green);
            border-radius: 50% 50% 42% 42%;
            position: absolute; bottom: 10px; left: 10px;
            animation: slimeBounce 0.7s ease-in-out infinite;
        }
        .title-slime::before {
            content: ''; position: absolute;
            width: 12px; height: 16px;
            background: white; border-radius: 50%;
            top: 14px; left: 18px;
            box-shadow: 26px 0 0 0 white;
        }
        .title-slime::after {
            content: ''; position: absolute;
            width: 7px; height: 10px;
            background: var(--bg); border-radius: 50%;
            top: 16px; left: 22px;
            box-shadow: 26px 0 0 0 var(--bg);
        }
        .title-shadow {
            position: absolute; bottom: 0; left: 10px;
            width: 80px; height: 12px;
            background: rgba(0,0,0,0.35);
            border-radius: 50%;
            animation: shadowPulse 0.7s ease-in-out infinite;
        }
        @keyframes slimeBounce {
            0%,100% { transform: translateY(0) scaleX(1) scaleY(1); }
            20% { transform: translateY(-25px) scaleX(0.88) scaleY(1.12); }
            50% { transform: translateY(0) scaleX(1.14) scaleY(0.86); }
            70% { transform: translateY(-8px) scaleX(0.95) scaleY(1.05); }
        }
        @keyframes shadowPulse {
            0%,100% { transform: scaleX(1); opacity: 0.35; }
            20% { transform: scaleX(0.7); opacity: 0.2; }
            50% { transform: scaleX(1.1); opacity: 0.4; }
        }

        /* ===== Buttons ===== */
        .btn {
            font-family: 'Press Start 2P', monospace;
            font-size: 12px; padding: 14px 28px;
            background: var(--panel); color: var(--white);
            border: 3px solid var(--white);
            cursor: pointer; text-transform: uppercase;
            outline: none; transition: all 0.1s;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }
        .btn:hover { background: var(--white); color: var(--bg); }
        .btn:active { transform: scale(0.95); }
        .btn.primary { border-color: var(--green); color: var(--green); }
        .btn.primary:hover { background: var(--green); color: var(--bg); }
        .blink { animation: blink 1s step-end infinite; }
        @keyframes blink { 50% { opacity: 0; } }

        /* ===== Setup ===== */
        #setup-screen {
            justify-content: flex-start;
            padding-top: 24px; gap: 12px;
            overflow-y: auto;
        }
        #setup-screen h2 {
            font-size: clamp(14px, 3vw, 20px);
            color: var(--yellow);
            text-shadow: 2px 2px 0 rgba(0,0,0,0.5);
            margin-bottom: 8px;
        }
        .setup-row {
            display: flex; align-items: center;
            gap: 12px; width: 100%; max-width: 480px;
        }
        .setup-label {
            font-size: 9px; min-width: 100px; text-align: right;
        }
        .count-controls {
            display: flex; align-items: center; gap: 10px;
        }
        .count-btn {
            font-family: 'Press Start 2P', monospace;
            font-size: 18px; width: 36px; height: 36px;
            background: var(--panel); color: var(--white);
            border: 3px solid var(--white);
            cursor: pointer; display: flex;
            align-items: center; justify-content: center;
        }
        .count-btn:hover { background: var(--white); color: var(--bg); }
        #player-count, #time-input {
            font-family: 'Press Start 2P', monospace;
            font-size: 16px; width: 76px; text-align: center;
            background: var(--panel); color: var(--white);
            border: 2px solid var(--border); outline: none;
            padding: 6px 2px; -moz-appearance: textfield;
        }
        #player-count::-webkit-inner-spin-button,
        #player-count::-webkit-outer-spin-button,
        #time-input::-webkit-inner-spin-button,
        #time-input::-webkit-outer-spin-button { -webkit-appearance: none; }
        #player-count:focus, #time-input:focus { border-color: var(--white); }
        .player-list {
            width: 100%; max-width: 480px;
            display: flex; flex-direction: column; gap: 6px;
        }
        .player-row {
            display: flex; align-items: center; gap: 8px;
        }
        .color-dot {
            width: 14px; height: 14px; border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.5); flex-shrink: 0;
        }
        .player-num { font-size: 9px; min-width: 20px; }
        .sd-input {
            font-family: 'Press Start 2P', monospace;
            font-size: 9px; padding: 7px 10px;
            background: #0a0a0a; color: var(--white);
            border: 2px solid #444; outline: none;
            flex: 1; max-width: 200px;
        }
        .sd-input:focus { border-color: var(--white); }
        .sd-checkbox {
            display: flex; align-items: center; gap: 10px;
            cursor: pointer; font-size: 9px; user-select: none;
        }
        .sd-checkbox input { display: none; }
        .sd-check-box {
            width: 18px; height: 18px;
            border: 3px solid #666; background: var(--panel);
            position: relative; flex-shrink: 0;
        }
        .sd-checkbox input:checked + .sd-check-box {
            border-color: var(--green);
        }
        .sd-checkbox input:checked + .sd-check-box::after {
            content: ''; position: absolute;
            top: 2px; left: 2px; right: 2px; bottom: 2px;
            background: var(--green);
        }
        .name-scroll {
            max-height: 200px; overflow-y: auto; width: 100%;
            display: flex; flex-direction: column; gap: 4px;
        }
        .name-scroll::-webkit-scrollbar { width: 6px; }
        .name-scroll::-webkit-scrollbar-track { background: var(--panel); }
        .name-scroll::-webkit-scrollbar-thumb { background: #444; border-radius: 3px; }
        .unit { font-size: 9px; color: var(--gray); }
        .select-info {
            font-size: 9px; color: var(--yellow); line-height: 1.8;
            text-align: center; padding: 14px;
            border: 2px dashed var(--border);
            width: 100%; max-width: 480px;
        }

        /* ===== Draw screen ===== */
        #select-screen h2 {
            font-size: clamp(14px, 3vw, 22px);
            color: var(--yellow);
            text-shadow: 2px 2px 0 rgba(0,0,0,0.5);
            margin-bottom: 6px;
        }
        .draw-sub { font-size: 10px; color: var(--gray); margin-bottom: 12px; }
        .draw-grid {
            display: grid; grid-template-columns: repeat(4, 1fr);
            gap: 10px; width: 100%; max-width: 460px; margin: 8px 0;
        }
        .draw-card {
            display: flex; align-items: center; gap: 8px;
            padding: 10px 12px; background: var(--panel);
            border: 3px solid; font-size: 11px;
            animation: cardPop 0.35s ease-out both;
        }
        .draw-dot {
            width: 12px; height: 12px; border-radius: 50%; flex-shrink: 0;
        }
        @keyframes cardPop {
            from { transform: scale(0) rotate(-10deg); opacity: 0; }
            to { transform: scale(1) rotate(0); opacity: 1; }
        }

        /* ===== Game ===== */
        #game-screen { 
            padding: 0;
            background: #000;
            overflow: hidden;
        }
        #race-canvas {
            max-width: 100%;
            max-height: 100vh;
            width: auto;
            height: auto;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            object-fit: contain;
            transition: transform 0.15s ease-out;
        }

        /* ===== Results ===== */
        #result-screen { gap: 16px; }
        #result-screen h2 {
            font-size: clamp(16px, 3vw, 26px);
            color: var(--yellow);
            text-shadow: 2px 2px 0 rgba(0,0,0,0.5);
        }
        #finish-snapshot {
            max-width: 520px; width: 100%;
            border: 3px solid var(--yellow);
            border-radius: 8px; overflow: hidden;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }
        #finish-snapshot img {
            width: 100%; display: block;
        }
        .results-list {
            width: 100%; max-width: 520px;
            display: flex; flex-direction: column; gap: 6px;
        }
        .res-row {
            display: flex; align-items: center; gap: 10px;
            padding: 10px 14px; background: var(--panel);
            border: 2px solid var(--border); font-size: 10px;
        }
        .res-row.w { border-color: var(--yellow); background: rgba(255,215,0,0.06); }
        .res-rank { min-width: 36px; font-weight: bold; }
        .res-rank.g { color: #ffd700; }
        .res-rank.s { color: #c0c0c0; }
        .res-rank.b { color: #cd7f32; }
        .res-dot { width: 12px; height: 12px; border-radius: 50%; flex-shrink: 0; }
        .res-name { flex: 1; }
        .res-time { color: #aaa; min-width: 80px; text-align: right; }
        .res-stats {
            font-size: 8px; color: #888;
            display: flex; gap: 8px; margin-left: auto;
        }
        .res-stats span { white-space: nowrap; }
        .btn-group { display: flex; gap: 12px; margin-top: 8px; flex-wrap: wrap; justify-content: center; }
        .btn-mobile { display: none; }
        .btn-full { display: inline; }

        /* ===== Mobile Responsive ===== */
        @media (max-width: 768px) {
            .screen { padding: 10px; }
            
            .btn-mobile { display: inline; }
            .btn-full { display: none; }
            
            #title-screen h1 {
                font-size: 32px;
            }
            .subtitle { font-size: 8px; }
            
            #setup-screen { padding-top: 10px; gap: 8px; }
            #setup-screen h2 { font-size: 14px; }
            
            .setup-row { flex-wrap: wrap; justify-content: center; }
            .setup-label { min-width: auto; text-align: center; width: 100%; font-size: 8px; }
            
            .count-btn { width: 32px; height: 32px; font-size: 16px; }
            #player-count, #time-input { font-size: 12px; padding: 8px; }
            
            .player-inputs { gap: 6px; }
            .player-row { font-size: 8px; gap: 6px; }
            .sd-input { font-size: 9px; padding: 6px; }
            
            .btn { padding: 10px 16px; font-size: 9px; }
            .btn-group { gap: 8px; }
            
            .draw-grid { grid-template-columns: repeat(2, 1fr); gap: 8px; }
            .draw-card { font-size: 9px; padding: 8px; }
            
            #result-screen { gap: 12px; padding: 10px; }
            #result-screen h2 { font-size: 18px; }
            
            #finish-snapshot { max-width: 100%; }
            
            .results-list { max-width: 100%; }
            .res-row { padding: 8px 10px; font-size: 8px; gap: 6px; }
            .res-rank { min-width: 28px; font-size: 8px; }
            .res-dot { width: 10px; height: 10px; }
            .res-name { font-size: 9px; }
            .res-time { min-width: 60px; font-size: 8px; }
            .res-stats { font-size: 7px; gap: 4px; }
        }

        @media (max-width: 480px) {
            #title-screen h1 { font-size: 24px; }
            .subtitle { font-size: 7px; }
            
            .btn { padding: 8px 12px; font-size: 8px; }
            
            .setup-label { font-size: 7px; }
            .count-btn { width: 28px; height: 28px; font-size: 14px; }
            
            .draw-card { font-size: 8px; padding: 6px; }
            
            .res-row { font-size: 7px; padding: 6px 8px; }
            .res-rank { font-size: 7px; min-width: 24px; }
            .res-name { font-size: 8px; }
            .res-time { font-size: 7px; }
        }

        @media (max-height: 500px) {
            #setup-screen { padding-top: 10px; gap: 6px; }
            .btn { padding: 10px 20px; font-size: 10px; }
        }
    </style>
</head>
<body>
<div id="app">
    <!-- Title -->
    <div id="title-screen" class="screen active">
        <div class="title-slime-container">
            <div class="title-slime"></div>
            <div class="title-shadow"></div>
        </div>
        <h1>SLIME<br>DERBY</h1>
        <p class="subtitle">Ïä¨ÎùºÏûÑ Í≤ΩÏ£ºÎ°ú ÏàúÏÑúÎ•º Ï†ïÌïòÏûê!</p>
        <button class="btn primary blink" onclick="showSetup()">PRESS START</button>
    </div>

    <!-- Setup -->
    <div id="setup-screen" class="screen">
        <h2>RACE SETUP</h2>
        <div class="setup-row">
            <span class="setup-label">Ï∞∏Í∞Ä Ïä¨ÎùºÏûÑ</span>
            <div class="count-controls">
                <button class="count-btn" onclick="changeCount(-1)">-</button>
                <input type="number" id="player-count" value="4" min="2" max="1000" oninput="setCount(this.value)">
                <button class="count-btn" onclick="changeCount(1)">+</button>
            </div>
        </div>
        <div class="setup-row">
            <span class="setup-label"></span>
            <label class="sd-checkbox">
                <input type="checkbox" id="use-names" onchange="buildPlayerInputs();saveSetup()">
                <span class="sd-check-box"></span>
                <span>Ïù¥Î¶Ñ ÏûÖÎ†•</span>
            </label>
        </div>
        <div class="setup-row">
            <span class="setup-label"></span>
            <label class="sd-checkbox">
                <input type="checkbox" id="use-nes-chars" onchange="saveSetup()">
                <span class="sd-check-box"></span>
                <span>NES Ï∫êÎ¶≠ÌÑ∞</span>
            </label>
        </div>
        <div class="setup-row">
            <span class="setup-label"></span>
            <label class="sd-checkbox">
                <input type="checkbox" id="early-finish" checked onchange="saveSetup()">
                <span class="sd-check-box"></span>
                <span>Ï°∞Í∏∞ Ï¢ÖÎ£å</span>
            </label>
        </div>
        <div class="player-list" id="player-list"></div>
        <div class="setup-row">
            <span class="setup-label">Î†àÏù¥Ïä§ ÏãúÍ∞Ñ</span>
            <div class="count-controls">
                <button class="count-btn" onclick="changeTime(-1)">-</button>
                <input type="number" id="time-input" value="10" min="3" max="60" oninput="setTime(this.value)">
                <button class="count-btn" onclick="changeTime(1)">+</button>
                <span class="unit">SEC</span>
            </div>
        </div>
        <div style="display:flex;gap:12px;margin-top:12px">
            <button class="btn" onclick="resetSetup()" style="font-size:10px">RESET</button>
            <button class="btn primary" onclick="startRace()" style="font-size:14px">START RACE!</button>
        </div>
    </div>

    <!-- Draw (selection) -->
    <div id="select-screen" class="screen">
        <h2>RANDOM DRAW</h2>
        <p class="draw-sub">Ï¥ù <span id="draw-total">0</span>Î™Ö Ï§ë <span style="color:var(--green)">8</span>Î™Ö ÏÑ†Î∞ú!</p>
        <div class="draw-grid" id="draw-grid"></div>
        <button class="btn primary" onclick="beginRace()" style="margin-top:12px;font-size:14px">START RACE!</button>
    </div>

    <!-- Game -->
    <div id="game-screen" class="screen">
        <canvas id="race-canvas"></canvas>
    </div>

    <!-- Results -->
    <div id="result-screen" class="screen">
        <h2>FINISH!</h2>
        <div id="finish-snapshot" style="margin-bottom: 16px;"></div>
        <div class="results-list" id="results-list"></div>
        <div style="margin: 12px 0; font-size: 10px; color: #888;">
            Enjoyed the game? <a href="https://buymeacoffee.com/honux77o" target="_blank" style="color: #FFDD00; text-decoration: none; font-weight: bold;">‚òï Buy me a coffee!</a>
        </div>
        <div class="btn-group">
            <button class="btn" onclick="downloadResults()"><span class="btn-full">üì• DOWNLOAD</span><span class="btn-mobile">üì•</span></button>
            <button class="btn" onclick="showSetup()">SETUP</button>
            <button class="btn primary" onclick="startRace()">REMATCH</button>
        </div>
    </div>
</div>

<script>
/* =========================================================
   SLIME DERBY - NES-style slime racing game
   ========================================================= */

// ‚îÄ‚îÄ Colors ‚îÄ‚îÄ
const SLIME_COLORS = [
    { hex: '#58d854', dark: '#2e8a2c', light: '#8aff88' },
    { hex: '#4488ff', dark: '#2255bb', light: '#88bbff' },
    { hex: '#ff4444', dark: '#bb2222', light: '#ff8888' },
    { hex: '#ffdd00', dark: '#bb9900', light: '#ffee88' },
    { hex: '#aa44ff', dark: '#7722bb', light: '#cc88ff' },
    { hex: '#ff88cc', dark: '#bb5588', light: '#ffbbee' },
    { hex: '#ff8800', dark: '#bb5500', light: '#ffbb66' },
    { hex: '#44dddd', dark: '#228888', light: '#88ffee' },
];
const DEFAULT_NAMES = ['Ï¥àÎ°ùÏù¥','ÌååÎûëÏù¥','Îπ®Í∞ïÏù¥','ÎÖ∏ÎûëÏù¥','Î≥¥Îùº','ÌïëÌÅ¨','Ï£ºÌô©Ïù¥','ÌïòÎäòÏù¥'];

const NES_CHARS = [
    { cls: 'nes-mario', name: 'ÎßàÎ¶¨Ïò§' },
    { cls: 'nes-ash', name: 'ÏÇ¨ÌÜ†Ïãú' },
    { cls: 'nes-kirby', name: 'Ïª§ÎπÑ' },
    { cls: 'nes-bulbasaur', name: 'Ïù¥ÏÉÅÌï¥Ïî®' },
    { cls: 'nes-charmander', name: 'ÌååÏù¥Î¶¨' },
    { cls: 'nes-squirtle', name: 'Íº¨Î∂ÄÍ∏∞' },
    { cls: 'nes-pokeball', name: 'Î™¨Ïä§ÌÑ∞Î≥º' },
    { cls: 'nes-octocat', name: 'Ïò•ÌÜ†Ï∫£' },
];
let nesCharImages = [];
let useNESChars = false;
let earlyFinish = false;
let earlyFinishTime = 0; // timestamp when 1st place finished

// ‚îÄ‚îÄ Canvas constants ‚îÄ‚îÄ
const CW = 800, CH = 480;
const TRACK_L = 130, TRACK_R = CW - 30;
const TRACK_LEN = TRACK_R - TRACK_L;
const HEADER_H = 46;
const CROWD_H = 24;

// ‚îÄ‚îÄ State ‚îÄ‚îÄ
let playerCount = 4;
let players = [];
let targetTime = 10;
let state = 'title';
let canvas, ctx, animId;
let raceStart = 0;
let cdValue = 0;
let cdTimer = null;
let finishOrder = [];
let pace = 1;
let frame = 0;
let particles = [];
let spectators = [];
let allDone = false;
let finishSnapshot = null;  // Canvas snapshot when 1st place finishes
let isMobile = false;  // Mobile detection
let cameraX = 0;  // Camera position for mobile

// ‚îÄ‚îÄ Audio ‚îÄ‚îÄ
let audioCtx;
let bgMusic = null;
let victoryMusic = null;

function initMusic() {
    if (!bgMusic) {
        bgMusic = new Audio('mp3/bg.mp3');
        bgMusic.loop = true;
        bgMusic.volume = 0.4;
    }
    if (!victoryMusic) {
        victoryMusic = new Audio('mp3/victory.mp3');
        victoryMusic.loop = false;
        victoryMusic.volume = 0.5;
    }
}

function playBgMusic() {
    initMusic();
    stopAllMusic();
    bgMusic.currentTime = 0;
    bgMusic.play().catch(e => console.log('Audio play failed:', e));
}

function playVictoryMusic() {
    initMusic();
    stopAllMusic();
    victoryMusic.currentTime = 0;
    victoryMusic.play().catch(e => console.log('Audio play failed:', e));
}

function stopAllMusic() {
    if (bgMusic) bgMusic.pause();
    if (victoryMusic) victoryMusic.pause();
}

function tone(freq, dur, type='square', vol=0.06) {
    try {
        if (!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)();
        const o = audioCtx.createOscillator(), g = audioCtx.createGain();
        o.type = type; o.frequency.value = freq;
        g.gain.value = vol;
        g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
        o.connect(g); g.connect(audioCtx.destination);
        o.start(); o.stop(audioCtx.currentTime + dur);
    } catch(e) {}
}
function sfxTick() { tone(520, 0.12); }
function sfxGo() { tone(1040, 0.25); }
function sfxCross() { tone(780, 0.08); }
function sfxFanfare() {
    tone(523,.12); setTimeout(()=>tone(659,.12),120);
    setTimeout(()=>tone(784,.12),240); setTimeout(()=>tone(1047,.35),380);
}
function sfxBoost() { tone(660,.06); setTimeout(()=>tone(880,.06),60); setTimeout(()=>tone(1100,.1),120); }
function sfxTrip() { tone(300,.08); setTimeout(()=>tone(180,.15,'sawtooth'),80); }
function sfxSleep() { tone(220,.2,'sine',0.04); }

// ‚îÄ‚îÄ NES character pre-rendering ‚îÄ‚îÄ
function preRenderNESChars() {
    nesCharImages = [];
    const container = document.createElement('div');
    container.style.cssText = 'position:absolute;left:-9999px;top:-9999px;';
    document.body.appendChild(container);

    for (const ch of NES_CHARS) {
        const el = document.createElement('i');
        el.className = ch.cls;
        container.appendChild(el);

        const style = window.getComputedStyle(el, '::before');
        const shadowStr = style.boxShadow;
        const baseColor = style.color;
        const pixelSize = parseInt(style.width) || 6;

        // Parse box-shadow: "rgb(r,g,b) Xpx Ypx 0px 0px, ..."
        const pixels = [];
        let maxX = 0, maxY = 0;

        if (shadowStr && shadowStr !== 'none') {
            // Split by commas that are NOT inside rgb()/rgba() parentheses
            const parts = [];
            let depth = 0, start = 0;
            for (let i = 0; i < shadowStr.length; i++) {
                if (shadowStr[i] === '(') depth++;
                else if (shadowStr[i] === ')') depth--;
                else if (shadowStr[i] === ',' && depth === 0) {
                    parts.push(shadowStr.substring(start, i).trim());
                    start = i + 1;
                }
            }
            parts.push(shadowStr.substring(start).trim());

            for (const part of parts) {
                // Match: optional color then Xpx Ypx ...
                const colorMatch = part.match(/^(rgba?\([^)]+\))\s+/);
                let color, rest;
                if (colorMatch) {
                    color = colorMatch[1];
                    rest = part.substring(colorMatch[0].length);
                } else {
                    color = baseColor || '#000';
                    rest = part;
                }
                const nums = rest.match(/-?\d+(\.\d+)?/g);
                if (nums && nums.length >= 2) {
                    const px = parseFloat(nums[0]);
                    const py = parseFloat(nums[1]);
                    pixels.push({ x: px, y: py, color });
                    if (px + pixelSize > maxX) maxX = px + pixelSize;
                    if (py + pixelSize > maxY) maxY = py + pixelSize;
                }
            }
        }

        // Also account for the ::before element itself (drawn at 0,0)
        if (maxX === 0) maxX = pixelSize;
        if (maxY === 0) maxY = pixelSize;

        const offCanvas = document.createElement('canvas');
        offCanvas.width = maxX;
        offCanvas.height = maxY;
        const offCtx = offCanvas.getContext('2d');

        // Draw the ::before element pixel at origin
        if (baseColor && baseColor !== 'rgba(0, 0, 0, 0)') {
            offCtx.fillStyle = baseColor;
            offCtx.fillRect(0, 0, pixelSize, pixelSize);
        }

        // Draw all shadow pixels
        for (const p of pixels) {
            offCtx.fillStyle = p.color;
            offCtx.fillRect(p.x, p.y, pixelSize, pixelSize);
        }

        nesCharImages.push(offCanvas);
    }
    document.body.removeChild(container);
}

// ‚îÄ‚îÄ Screen management ‚îÄ‚îÄ
function showScreen(id) {
    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    document.getElementById(id).classList.add('active');
}
function showSetup() {
    state = 'setup';
    if (animId) { cancelAnimationFrame(animId); animId = null; }
    if (cdTimer) { clearTimeout(cdTimer); cdTimer = null; }
    stopAllMusic();  // Stop all music when returning to setup
    
    // Reset canvas transform if exists
    const raceCanvas = document.getElementById('race-canvas');
    if (raceCanvas) {
        raceCanvas.style.transform = '';
        raceCanvas.style.transformOrigin = '';
    }
    
    showScreen('setup-screen');
    buildPlayerInputs();
}

// ‚îÄ‚îÄ Setup UI ‚îÄ‚îÄ
function changeCount(d) {
    playerCount = Math.max(2, Math.min(1000, playerCount + d));
    document.getElementById('player-count').value = playerCount;
    buildPlayerInputs();
    saveSetup();
    sfxTick();
}

function setCount(val) {
    const n = parseInt(val);
    if (!isNaN(n)) playerCount = Math.max(2, Math.min(1000, n));
    buildPlayerInputs();
    saveSetup();
}

function changeTime(d) {
    targetTime = Math.max(3, Math.min(60, (parseInt(document.getElementById('time-input').value) || 10) + d));
    document.getElementById('time-input').value = targetTime;
    saveSetup();
    sfxTick();
}

function setTime(val) {
    const n = parseInt(val);
    if (!isNaN(n)) targetTime = Math.max(3, Math.min(60, n));
    document.getElementById('time-input').value = targetTime;
    saveSetup();
}

function buildPlayerInputs() {
    const box = document.getElementById('player-list');
    const useNames = document.getElementById('use-names').checked;

    // Remember existing names before clearing
    const old = {};
    box.querySelectorAll('input').forEach(inp => {
        if (inp.dataset.idx != null) old[inp.dataset.idx] = inp.value;
    });
    box.innerHTML = '';

    // Info banner for > 8
    if (playerCount > 8) {
        const info = document.createElement('div');
        info.className = 'select-info';
        info.innerHTML = `Ï¥ù ${playerCount}Î™Ö Ï§ë 8Î™ÖÏù¥<br>ÎûúÎç§ÏúºÎ°ú ÏÑ†Î∞úÎê©ÎãàÎã§`;
        box.appendChild(info);
    }

    if (!useNames) return;

    // Name inputs
    const wrap = document.createElement('div');
    if (playerCount > 8) wrap.className = 'name-scroll';
    const count = playerCount;
    for (let i = 0; i < count; i++) {
        const row = document.createElement('div');
        row.className = 'player-row';
        const placeholder = i < 8 && playerCount <= 8 ? DEFAULT_NAMES[i] : `Ï∞∏Í∞ÄÏûê${i + 1}`;
        const dot = playerCount <= 8
            ? `<div class="color-dot" style="background:${SLIME_COLORS[i].hex}"></div>` : '';
        row.innerHTML = `
            ${dot}
            <span class="player-num">${i+1}.</span>
            <input class="sd-input" type="text" maxlength="8"
                   data-idx="${i}" placeholder="${placeholder}"
                   value="${old[i] !== undefined ? old[i] : ''}"
                   onblur="saveSetup()">`;
        wrap.appendChild(row);
    }
    box.appendChild(wrap);
}

// ‚îÄ‚îÄ Player factory ‚îÄ‚îÄ
function makePlayer(name, colorIdx) {
    return {
        name, color: SLIME_COLORS[colorIdx],
        pos: 0, speed: 0,
        mult: 0.8 + Math.random() * 0.4,
        talent: 0.92 + Math.random() * 0.16,
        changeTimer: 20 + Math.floor(Math.random() * 40),
        nextChange: 0,
        finished: false, finishTime: 0, rank: -1, dnf: false,
        hopT: Math.random(), hopSpd: 0, wasAir: false,
        fx: null, fxTimer: 0, fxCooldown: 0,
        y: 0, laneTop: 0, laneH: 0,
        // Stats tracking
        boostCount: 0, tripCount: 0, sleepCount: 0,
    };
}

function pickRandom(total, k) {
    const set = new Set();
    while (set.size < k) set.add(Math.floor(Math.random() * total) + 1);
    return [...set].sort((a, b) => a - b);
}

// ‚îÄ‚îÄ Start race ‚îÄ‚îÄ
function startRace() {
    playerCount = Math.max(2, Math.min(1000,
        parseInt(document.getElementById('player-count').value) || 4));
    document.getElementById('player-count').value = playerCount;
    targetTime = Math.max(3, Math.min(60,
        parseInt(document.getElementById('time-input').value) || 10));
    const useNames = document.getElementById('use-names').checked;
    saveSetup();

    // Collect entered names (indexed by 0-based position)
    const nameMap = {};
    if (useNames) {
        document.querySelectorAll('#player-list input[data-idx]').forEach(inp => {
            const v = inp.value.trim();
            if (v) nameMap[parseInt(inp.dataset.idx)] = v;
        });
    }

    const nesMode = document.getElementById('use-nes-chars').checked;
    const defaultNames = nesMode ? NES_CHARS.map(c => c.name) : DEFAULT_NAMES;

    if (playerCount <= 8) {
        players = [];
        for (let i = 0; i < playerCount; i++) {
            const name = nameMap[i] || defaultNames[i];
            players.push(makePlayer(name, i));
        }
        beginRace();
    } else {
        const picked = pickRandom(playerCount, 8);
        players = [];
        for (let i = 0; i < 8; i++) {
            const num = picked[i];
            const name = nameMap[num - 1] || ('#' + num);
            players.push(makePlayer(name, i));
        }
        showDraw(picked);
    }
}

function showDraw(picked) {
    state = 'draw';
    showScreen('select-screen');
    document.getElementById('draw-total').textContent = playerCount;
    const grid = document.getElementById('draw-grid');
    grid.innerHTML = '';
    for (let i = 0; i < picked.length; i++) {
        const card = document.createElement('div');
        card.className = 'draw-card';
        card.style.borderColor = SLIME_COLORS[i].hex;
        card.style.animationDelay = (i * 0.12) + 's';
        const label = players[i].name;
        card.innerHTML = `
            <div class="draw-dot" style="background:${SLIME_COLORS[i].hex}"></div>
            <span>${label}</span>`;
        grid.appendChild(card);
    }
}

// ‚îÄ‚îÄ Stadium ‚îÄ‚îÄ
const CROWD_SKINS = ['#ffdbac','#f1c27d','#e0ac69','#c68642','#8d5524'];
const CROWD_HAIRS = ['#1a1a2e','#4a2810','#8b6914','#d4a030','#a02020','#3060a0','#206030','#e8e0d0'];
const CROWD_OUTFITS = ['#cc2222','#2255cc','#22aa44','#ddaa00','#8833cc','#cc5599','#dd7700','#22bbbb','#ddd','#666'];
function pick(a) { return a[Math.floor(Math.random()*a.length)]; }

function generateSpectators() {
    spectators = [];
    const tTop = HEADER_H + CROWD_H, tBot = CH - CROWD_H;
    const rows = [
        { y: HEADER_H + 2 }, { y: HEADER_H + 12 },
        { y: tBot + 4 }, { y: tBot + 14 },
    ];
    for (const r of rows) {
        for (let x = TRACK_L - 8; x < CW - 6; x += 7 + Math.random() * 5) {
            spectators.push({
                x: Math.round(x), y: r.y,
                skin: pick(CROWD_SKINS), hair: pick(CROWD_HAIRS),
                outfit: pick(CROWD_OUTFITS),
                phase: Math.random() * Math.PI * 2,
                spd: 0.035 + Math.random() * 0.025,
            });
        }
    }
}

function renderStadium() {
    const w = CW, h = CH;
    const tTop = HEADER_H + CROWD_H, tBot = h - CROWD_H;

    // Sky
    ctx.fillStyle = '#0d1b2a';
    ctx.fillRect(0, 0, w, h);

    // Grass bands
    ctx.fillStyle = '#1a3a12';
    ctx.fillRect(0, HEADER_H, w, CROWD_H);
    ctx.fillRect(0, tBot, w, CROWD_H);
    ctx.fillStyle = '#163010';
    for (let gx = 0; gx < w; gx += 14) {
        ctx.fillRect(gx, HEADER_H, 5, CROWD_H);
        ctx.fillRect(gx + 7, tBot, 5, CROWD_H);
    }

    // Bleacher tiers
    ctx.fillStyle = '#16102a';
    ctx.fillRect(TRACK_L - 12, HEADER_H, w - TRACK_L + 20, 10);
    ctx.fillStyle = '#1c1430';
    ctx.fillRect(TRACK_L - 12, HEADER_H + 10, w - TRACK_L + 20, CROWD_H - 13);
    ctx.fillStyle = '#16102a';
    ctx.fillRect(TRACK_L - 12, tBot + 3, w - TRACK_L + 20, 10);
    ctx.fillStyle = '#1c1430';
    ctx.fillRect(TRACK_L - 12, tBot + 13, w - TRACK_L + 20, CROWD_H - 13);

    // Spectators
    const anim = performance.now() * 0.003;
    for (const s of spectators) {
        const bob = Math.round(Math.sin(s.phase + anim * (1 + s.spd * 12)) * 1.2);
        const x = s.x, y = s.y + bob;
        ctx.fillStyle = s.hair;
        ctx.fillRect(x, y, 4, 2);
        ctx.fillStyle = s.skin;
        ctx.fillRect(x, y + 2, 4, 2);
        ctx.fillStyle = s.outfit;
        ctx.fillRect(x - 1, y + 4, 6, 3);
        // Arms up (cheering)
        if (Math.sin(s.phase * 3 + anim * (1.3 + s.spd * 10)) > 0.6) {
            ctx.fillStyle = s.skin;
            ctx.fillRect(x - 2, y + 3, 2, 2);
            ctx.fillRect(x + 4, y + 3, 2, 2);
        }
    }

    // Fences
    const drawFence = (fy) => {
        ctx.fillStyle = '#8b7355';
        ctx.fillRect(TRACK_L - 8, fy, w - TRACK_L + 16, 2);
        ctx.fillStyle = '#6b5335';
        ctx.fillRect(TRACK_L - 8, fy + 3, w - TRACK_L + 16, 1);
        for (let fx = TRACK_L - 5; fx < w; fx += 26)
            ctx.fillRect(fx, fy - 1, 2, 6);
    };
    drawFence(tTop - 3);
    drawFence(tBot + 1);

    // Track surface
    for (let i = 0; i < players.length; i++) {
        const p = players[i];
        ctx.fillStyle = i % 2 === 0 ? '#2e2015' : '#261a10';
        ctx.fillRect(TRACK_L - 5, p.laneTop, w - TRACK_L + 10, p.laneH);
    }
    // Green edge strips
    ctx.fillStyle = '#1e4215';
    ctx.fillRect(TRACK_L - 5, tTop, w - TRACK_L + 10, 2);
    ctx.fillRect(TRACK_L - 5, tBot - 2, w - TRACK_L + 10, 2);

    // Name panel
    ctx.fillStyle = '#0a0a18';
    ctx.fillRect(0, tTop, TRACK_L - 6, tBot - tTop);
}

function beginRace() {
    // Read NES character toggle
    useNESChars = document.getElementById('use-nes-chars').checked;
    if (useNESChars) preRenderNESChars();
    earlyFinish = document.getElementById('early-finish').checked;
    earlyFinishTime = 0;

    canvas = document.getElementById('race-canvas');
    ctx = canvas.getContext('2d');
    canvas.width = CW; canvas.height = CH;
    ctx.imageSmoothingEnabled = false;
    
    // Mobile detection and camera reset
    isMobile = window.innerWidth <= 768;
    cameraX = 0;
    
    if (isMobile) {
        // Calculate initial camera position for mobile
        const scale = 2.0;
        const ratio = window.innerWidth / CW;
        
        // Target: Leader (at TRACK_L) should be at 1/3 screen width
        // Formula: (ElementPx + offsetX) * scale = screenW / 3
        const startPx = TRACK_L * ratio;
        const targetOffset = (window.innerWidth / 3 / scale) - startPx;
        
        // Clamp to max 0 (start limit)
        cameraX = Math.min(0, targetOffset);
        
        canvas.style.transform = `scale(${scale}) translateX(${cameraX}px)`;
        canvas.style.transformOrigin = 'left center';
    } else {
        canvas.style.transform = '';
        canvas.style.transformOrigin = '';
    }

    // Lane positions (accounting for crowd bands)
    const raceCount = players.length;
    const trackTop = HEADER_H + CROWD_H;
    const trackBot = CH - CROWD_H;
    const trackH = trackBot - trackTop;
    const laneH = trackH / raceCount;
    for (let i = 0; i < raceCount; i++) {
        players[i].laneTop = trackTop + laneH * i;
        players[i].laneH = laneH;
        players[i].y = trackTop + laneH * i + laneH / 2;
    }
    generateSpectators();

    finishOrder = []; pace = 1; frame = 0; particles = []; finishSnapshot = null;
    showScreen('game-screen');

    // Countdown
    state = 'countdown'; cdValue = 3;
    playBgMusic();  // Start background music
    sfxTick();
    const countDown = () => {
        cdValue--;
        if (cdValue > 0) { sfxTick(); cdTimer = setTimeout(countDown, 800); }
        else {
            sfxGo(); cdValue = 0;
            cdTimer = setTimeout(() => {
                state = 'racing';
                raceStart = performance.now();
            }, 400);
        }
    };
    cdTimer = setTimeout(countDown, 800);

    if (animId) cancelAnimationFrame(animId);
    loop();
}

function spawnFxText(p, text, color) {
    particles.push({
        x: TRACK_L + p.pos, y: p.y - 20,
        vx: 0, vy: -0.6,
        size: 0, life: 50, maxLife: 50,
        color, grav: false, text,
    });
}

// ‚îÄ‚îÄ Race update ‚îÄ‚îÄ
function updateRace() {
    if (state !== 'racing') return;
    frame++;
    const elapsed = (performance.now() - raceStart) / 1000;
    const baseSpd = TRACK_LEN / (targetTime * 60);

    // Pace control ‚Äî calibrate so the LAST finisher crosses near targetTime
    let minProg = 1;
    for (const p of players) {
        if (!p.finished) minProg = Math.min(minProg, p.pos / TRACK_LEN);
    }
    const expected = Math.min(elapsed / targetTime, 1.0);
    if (minProg > 0.005) {
        const target = expected / minProg;
        pace += (target - pace) * 0.08;
        pace = Math.max(0.15, Math.min(6, pace));
    }

    allDone = true;
    const justFinished = [];

    for (const p of players) {
        if (p.finished) continue;
        allDone = false;

        // Speed variation
        p.nextChange--;
        if (p.nextChange <= 0) {
            p.mult = 0.35 + Math.random() * 1.3;
            p.nextChange = 25 + Math.floor(Math.random() * 80);
        }

        // ‚îÄ‚îÄ Special effects ‚îÄ‚îÄ
        if (p.fxCooldown > 0) p.fxCooldown--;
        if (p.fxTimer > 0) {
            p.fxTimer--;
            if (p.fxTimer <= 0) p.fx = null;
        }
        // Trigger new effect (only if none active, off cooldown, not near start/finish)
        const prog = p.pos / TRACK_LEN;
        if (!p.fx && p.fxCooldown <= 0 && prog > 0.08 && prog < 0.88) {
            const roll = Math.random();
            if (roll < 0.003) {         // ~0.3% per frame ‚âà every ~5.5s
                p.fx = 'boost'; p.fxTimer = 55; p.fxCooldown = 120;
                p.boostCount++;
                sfxBoost();
                spawnFxText(p, 'BOOST!', '#ffdd00');
            } else if (roll < 0.005) {  // ~0.2%
                p.fx = 'trip'; p.fxTimer = 50; p.fxCooldown = 120;
                p.tripCount++;
                sfxTrip();
                spawnFxText(p, 'TRIP!', '#ff4444');
            } else if (roll < 0.007) {  // ~0.2%
                p.fx = 'sleep'; p.fxTimer = 80; p.fxCooldown = 120;
                p.sleepCount++;
                sfxSleep();
                spawnFxText(p, 'Zzz..', '#88aaff');
            }
        }

        // Effect speed modifier
        let fxMult = 1;
        if (p.fx === 'boost') fxMult = 2.0;
        else if (p.fx === 'trip') fxMult = (p.fxTimer > 35) ? 0.0 : (50 - p.fxTimer) / 50;
        else if (p.fx === 'sleep') fxMult = 0.25;

        // Effect particles
        const px = TRACK_L + p.pos, py = p.y;
        if (p.fx === 'boost' && frame % 3 === 0) {
            particles.push({ x: px-10, y: py+(Math.random()-0.5)*8,
                vx: -3-Math.random()*3, vy: 0, size: 1.5+Math.random()*2,
                life: 10, maxLife: 10, color: '#ffdd00', grav: false });
        }
        if (p.fx === 'trip' && p.fxTimer > 30 && frame % 6 === 0) {
            for (let s = 0; s < 2; s++) {
                const ang = Math.random() * Math.PI * 2;
                particles.push({ x: px+Math.cos(ang)*12, y: py-14+Math.sin(ang)*6,
                    vx: Math.cos(ang)*0.3, vy: Math.sin(ang)*0.3,
                    size: 1.5, life: 14, maxLife: 14, color: '#ffff44', grav: false });
            }
        }
        if (p.fx === 'sleep' && frame % 18 === 0) {
            particles.push({ x: px+6, y: py-12,
                vx: 0.3+Math.random()*0.3, vy: -0.5-Math.random()*0.3,
                size: 0, life: 35, maxLife: 35, color: '#88aaff', grav: false, text: 'z' });
        }

        // Rubber band
        const avg = players.reduce((s,q) => s + q.pos, 0) / players.length / TRACK_LEN;
        const my = p.pos / TRACK_LEN;
        const rubber = 1 + (avg - my) * 0.1;

        const spd = baseSpd * p.mult * p.talent * pace * rubber * fxMult;
        const rawPos = p.pos + spd;
        p.pos = Math.min(rawPos, TRACK_LEN);

        // Hop animation ‚Äî faster movement = faster hops
        const prevT = p.hopT;
        p.hopSpd = 0.008 + Math.min(0.035, spd * 0.022);
        p.hopT = (p.hopT + p.hopSpd) % 1;
        const isAir = p.hopT >= 0.10 && p.hopT < 0.55;
        const justLanded = p.wasAir && !isAir && p.hopT >= 0.55;
        p.wasAir = isAir;

        // Landing dust burst
        if (justLanded) {
            for (let d = 0; d < 4; d++) {
                particles.push({
                    x: TRACK_L + p.pos + (Math.random()-0.5)*10,
                    y: p.y + p.laneH * 0.18,
                    vx: (Math.random()-0.5)*2.5, vy: -Math.random()*1.5,
                    size: 2 + Math.random() * 2.5,
                    life: 16, maxLife: 16,
                    color: p.color.light, grav: false,
                });
            }
        }
        // Occasional trail dust while airborne
        if (isAir && frame % 10 === 0) {
            particles.push({
                x: TRACK_L + p.pos - 8,
                y: p.y + p.laneH * 0.15,
                vx: -Math.random() * 1.2, vy: -Math.random() * 0.5,
                size: 1.5 + Math.random() * 1.5,
                life: 14, maxLife: 14,
                color: p.color.light, grav: false,
            });
        }

        // Finish check
        if (p.pos >= TRACK_LEN) {
            p.finished = true;
            p.finishTime = elapsed;
            justFinished.push({ p, over: rawPos - TRACK_LEN });
        }
    }

    // Sort simultaneous finishers by overshoot
    justFinished.sort((a, b) => b.over - a.over);
    for (const jf of justFinished) {
        jf.p.rank = finishOrder.length;
        finishOrder.push(jf.p);
        
        // Capture snapshot when 1st place finishes
        if (finishOrder.length === 1 && !finishSnapshot) {
            finishSnapshot = canvas.toDataURL('image/png');
            if (earlyFinish) earlyFinishTime = performance.now();
        }
        
        sfxCross();
        // Celebration particles
        for (let i = 0; i < 20; i++) {
            particles.push({
                x: TRACK_R, y: jf.p.y,
                vx: (Math.random()-0.5)*6, vy: -Math.random()*5-1,
                size: 2+Math.random()*3, life: 50, maxLife: 50,
                color: ['#ffd700','#ff4444','#fff','#58d854',jf.p.color.hex][Math.floor(Math.random()*5)],
                grav: true,
            });
        }
    }

    // Crowd cheering text
    if (!allDone) {
        const cheerRate = elapsed / targetTime > 0.7 ? 0.04 : 0.02;  // Much higher frequency
        if (Math.random() < cheerRate) {
            const cheers = ['{n} Ïù¥Í≤®Îùº!','{n} ÌôîÏù¥ÌåÖ!','Îã¨Î†§ {n}!','{n} ÌûòÎÇ¥!',
                'Í∞ÄÏûê {n}!','{n}!!','Îπ®Î¶¨Îπ®Î¶¨!','Ïö∞ÏôÄ~!','ÌååÏù¥ÌåÖ!','ÏµúÍ≥† {n}!'];
            const cheerColors = ['#c92a2a','#087f5b','#c2255c','#5f3dc4','#1864ab','#0b7285','#2b8a3e','#d9480f'];
            const rp = players[Math.floor(Math.random() * players.length)];
            const text = pick(cheers).replace('{n}', rp.name);
            const isTop = Math.random() > 0.5;
            particles.push({
                x: TRACK_L + 40 + Math.random() * (TRACK_LEN - 100),
                y: isTop ? HEADER_H + CROWD_H - 6 : CH - CROWD_H + 6,
                vx: (Math.random() - 0.5) * 0.15,  // Slower horizontal movement
                vy: isTop ? 0.2 : -0.2,  // Slower vertical movement toward track
                size: 0, life: 120, maxLife: 120,  // Doubled lifetime (2 seconds at 60fps)
                color: pick(cheerColors), grav: false, text,
            });
        }
    }

    // Particles
    for (let i = particles.length - 1; i >= 0; i--) {
        const pt = particles[i];
        pt.life--;
        if (pt.grav) { pt.x += pt.vx; pt.y += pt.vy; pt.vy += 0.12; }
        else { pt.x += pt.vx||0; pt.y += pt.vy||0; }
        if (pt.life <= 0) particles.splice(i, 1);
    }

    // Early finish: 3 seconds after 1st place, force-finish remaining players
    if (earlyFinish && earlyFinishTime > 0 && !allDone && state === 'racing') {
        const sinceWin = (performance.now() - earlyFinishTime) / 1000;
        if (sinceWin >= 3) {
            // Rank unfinished players by current position (descending)
            const unfinished = players.filter(p => !p.finished);
            unfinished.sort((a, b) => b.pos - a.pos);
            for (const p of unfinished) {
                p.finished = true;
                p.dnf = true;
                p.finishTime = elapsed;
                p.rank = finishOrder.length;
                finishOrder.push(p);
            }
            allDone = true;
        }
    }

    if (allDone && state === 'racing') {
        state = 'finished';
        sfxFanfare();
        setTimeout(showResults, 2200);
    }
}

// ‚îÄ‚îÄ Update camera for mobile ‚îÄ‚îÄ
function updateMobileCamera() {
    if (!isMobile || (state !== 'racing' && state !== 'countdown' && state !== 'finished') || !canvas) return;
    
    // Find the leader (highest position)
    let leader = null;
    let maxPos = -1;
    for (const p of players) {
        if (p.pos > maxPos) {
            maxPos = p.pos;
            leader = p;
        }
    }
    
    if (!leader) return;
    
    const scale = 2.0;
    const ratio = window.innerWidth / CW;
    
    // Leader element position (relative to unscaled canvas)
    const leaderPx = (TRACK_L + leader.pos) * ratio;
    
    // Target offset: Place leader at 1/3 screen width
    // Formula: (leaderPx + offset) * scale = screenW / 3
    const targetOffset = (window.innerWidth / 3 / scale) - leaderPx;
    
    // Clamping limits (offsetX is negative, so higher is left, lower is right)
    // Max: 0 (Visual left edge aligned with Start area)
    const maxOffset = 0;
    
    // Min: Stop when Finish Line (TRACK_R) touches Right Edge
    // (TRACK_R * ratio + offset) * scale >= screenW 
    // => offset >= (screenW / scale) - (TRACK_R * ratio)
    const minOffset = (window.innerWidth / scale) - (TRACK_R * ratio);
    
    // Clamp
    let clamped = Math.max(minOffset, Math.min(maxOffset, targetOffset));
    
    // Smooth
    if (Math.abs(cameraX - clamped) > 1) {
        cameraX += (clamped - cameraX) * 0.15;
    } else {
        cameraX = clamped;
    }
    
    canvas.style.transform = `scale(${scale}) translateX(${cameraX}px)`;
    canvas.style.transformOrigin = 'left center';
}

// ‚îÄ‚îÄ Hop animation curve ‚îÄ‚îÄ
// t: 0‚Üí1 hop cycle, jumpH: max jump height in px
// Returns { yOff (negative=up), sx, sy }
function getHopAnim(t, jumpH) {
    let yOff = 0, sx = 1, sy = 1;
    if (t < 0.10) {
        // Crouch ‚Äî prepare to jump: squash down
        const p = t / 0.10;
        const ease = p * p; // ease-in
        sx = 1 + 0.16 * ease;
        sy = 1 - 0.16 * ease;
        yOff = 2 * ease;
    } else if (t < 0.55) {
        // Airborne ‚Äî parabolic arc, stretched body
        const p = (t - 0.10) / 0.45;
        const arc = Math.sin(p * Math.PI);
        yOff = -jumpH * arc + 2 * (1 - p);
        // Stretch vertically in the air
        const stretchP = Math.sin(p * Math.PI); // peaks mid-air
        sx = 1 - 0.14 * stretchP;   // narrower
        sy = 1 + 0.18 * stretchP;   // taller
    } else {
        // Landing ‚Äî pudding wobble (damped oscillation)
        const p = (t - 0.55) / 0.45;
        const wobble = Math.sin(p * Math.PI * 3.5) * Math.exp(-p * 3.8);
        sx = 1 + wobble * 0.22;
        sy = 1 - wobble * 0.22;
        yOff = Math.abs(wobble) * 1.5;
    }
    return { yOff, sx, sy };
}

// ‚îÄ‚îÄ Render ‚îÄ‚îÄ
function render() {
    const w = CW, h = CH;
    ctx.clearRect(0, 0, w, h);
    
    // Stadium background (grass, stands, spectators, fences, track)
    renderStadium();

    // Header bar
    ctx.fillStyle = '#080818';
    ctx.fillRect(0, 0, w, HEADER_H);
    ctx.fillStyle = '#1a1a3a';
    ctx.fillRect(0, HEADER_H - 1, w, 1);

    // Title
    ctx.font = '12px "Press Start 2P"';
    ctx.fillStyle = '#58d854';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    ctx.fillText('SLIME DERBY', 12, 16);

    // Timer
    if (state === 'racing' || state === 'finished') {
        const el = (performance.now() - raceStart) / 1000;
        ctx.font = '11px "Press Start 2P"';
        ctx.fillStyle = '#ffdd00';
        ctx.textAlign = 'right';
        ctx.fillText('TIME ' + el.toFixed(1) + 's', w - 12, 16);

        // Ranking bar
        const sorted = [...players].sort((a,b) => b.pos - a.pos);
        ctx.font = '7px "Press Start 2P"';
        ctx.textAlign = 'left';
        let rx = 12;
        for (let i = 0; i < Math.min(sorted.length, 6); i++) {
            ctx.fillStyle = sorted[i].color.hex;
            ctx.fillText(`${i+1}.${sorted[i].name}`, rx, 36);
            rx += ctx.measureText(`${i+1}.${sorted[i].name}`).width + 14;
            if (rx > w - 60) break;
        }
    }

    // Lane details (dividers, color bars, names)
    const tTop = HEADER_H + CROWD_H, tBot = h - CROWD_H;
    for (let i = 0; i < players.length; i++) {
        const p = players[i];
        ctx.fillStyle = '#4a3820';
        ctx.fillRect(TRACK_L, p.laneTop + p.laneH - 1, w - TRACK_L, 1);
        ctx.fillStyle = p.color.hex;
        ctx.fillRect(3, p.laneTop + 3, 4, p.laneH - 6);
        const fontSize = Math.min(9, p.laneH * 0.22);
        ctx.font = fontSize + 'px "Press Start 2P"';
        ctx.fillStyle = '#ddd';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        ctx.fillText(`${i+1}.${p.name}`, 12, p.y);
    }

    // Start line
    ctx.strokeStyle = '#ffffff44';
    ctx.lineWidth = 2;
    ctx.setLineDash([6, 4]);
    ctx.beginPath();
    ctx.moveTo(TRACK_L, tTop);
    ctx.lineTo(TRACK_L, tBot);
    ctx.stroke();
    ctx.setLineDash([]);

    // Finish line (checkered)
    const csz = Math.max(6, Math.floor(players[0]?.laneH / 5) || 8);
    const flW = csz * 2;
    for (let y = tTop; y < tBot; y += csz) {
        for (let x = 0; x < flW; x += csz) {
            const dark = ((x/csz)+(Math.floor((y-tTop)/csz))) % 2 === 0;
            ctx.fillStyle = dark ? '#222' : '#ddd';
            ctx.fillRect(TRACK_R - flW/2 + x, y,
                Math.min(csz, flW - x), Math.min(csz, tBot - y));
        }
    }

    // Particles (behind slimes) - only non-text particles
    for (const pt of particles) {
        if (!pt.text) {
            const a = pt.life / pt.maxLife;
            ctx.globalAlpha = a * 0.8;
            ctx.fillStyle = pt.color;
            ctx.beginPath();
            ctx.arc(pt.x, pt.y, pt.size, 0, Math.PI*2);
            ctx.fill();
        }
    }
    ctx.globalAlpha = 1;

    // Slimes
    for (let i = 0; i < players.length; i++) {
        const p = players[i];
        const sx = TRACK_L + p.pos;
        const sy = p.y;
        const sz = Math.min(18, p.laneH * 0.32);
        const jumpH = sz * 1.8;
        let bY, sqX, sqY;
        if (p.finished) {
            const idle = Math.sin(performance.now() * 0.004 + i * 2);
            bY = 0;
            sqX = 1 + idle * 0.03;
            sqY = 1 - idle * 0.03;
        } else if (p.fx === 'trip' && p.fxTimer > 30) {
            // Flattened on the ground
            bY = sz * 0.3;
            sqX = 1.5;
            sqY = 0.4;
        } else {
            const hop = getHopAnim(p.hopT, jumpH);
            bY = hop.yOff;
            sqX = hop.sx;
            sqY = hop.sy;
        }
        // Effect tint
        let drawColor = p.color;
        if (p.fx === 'boost') {
            // Flash between normal and bright
            const flash = Math.sin(frame * 0.5) > 0;
            drawColor = flash ? { hex: '#ffffaa', dark: '#cccc66', light: '#ffffdd' } : p.color;
        } else if (p.fx === 'sleep') {
            drawColor = { hex: p.color.hex + '99', dark: p.color.dark, light: p.color.light };
        }
        const isWinner = finishOrder.length > 0 && finishOrder[0] === p;
        // Dim sleeping slimes
        if (p.fx === 'sleep') ctx.globalAlpha = 0.55;
        if (useNESChars) {
            drawNESChar(sx, sy + bY, sz, sqX, sqY, i, isWinner);
        } else {
            drawSlime(sx, sy + bY, sz, sqX, sqY, drawColor, isWinner);
        }
        if (p.fx === 'sleep') ctx.globalAlpha = 1;
    }

    // Countdown overlay
    if (state === 'countdown') {
        ctx.fillStyle = 'rgba(0,0,0,0.55)';
        ctx.fillRect(0, 0, w, h);
        ctx.font = '64px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        if (cdValue > 0) {
            ctx.fillStyle = '#ffdd00';
            ctx.fillText(cdValue, w/2, h/2);
        } else {
            ctx.fillStyle = '#58d854';
            ctx.fillText('GO!', w/2, h/2);
        }
    }

    // Finish overlay
    if (state === 'finished') {
        const pulse = 0.8 + Math.sin(performance.now()/200) * 0.2;
        ctx.globalAlpha = pulse;
        ctx.font = '28px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = '#ffd700';
        ctx.shadowColor = '#ffd700';
        ctx.shadowBlur = 16;
        ctx.fillText('FINISH!', w/2, h/2);
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1;
    }

    // Text particles (crowd cheers) - drawn on top of slimes
    for (const pt of particles) {
        if (pt.text) {
            const a = pt.life / pt.maxLife;
            ctx.globalAlpha = a * 0.9;
            const fs = pt.text.length > 5 ? 6 : pt.text.length > 2 ? 8 : 10;
            ctx.font = `bold ${fs}px "Press Start 2P"`;
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            
            // Measure text for bubble size
            const metrics = ctx.measureText(pt.text);
            const textW = metrics.width;
            const textH = fs;
            const padding = 4;
            const bubbleW = textW + padding * 2;
            const bubbleH = textH + padding * 2;
            
            // Draw speech bubble background
            ctx.fillStyle = '#fff';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.roundRect(pt.x - bubbleW/2, pt.y - bubbleH/2, bubbleW, bubbleH, 3);
            ctx.fill();
            ctx.stroke();
            
            // Draw text
            ctx.fillStyle = pt.color;
            ctx.fillText(pt.text, pt.x, pt.y);
        }
    }
    ctx.globalAlpha = 1;

    ctx.textBaseline = 'alphabetic';
}

// ‚îÄ‚îÄ Draw slime ‚îÄ‚îÄ
function drawSlime(x, y, size, sx, sy, color, crown) {
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(sx, sy);

    const rw = size, rh = size * 0.82;

    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.25)';
    ctx.beginPath();
    ctx.ellipse(0, rh * 0.55, rw * 0.75, rh * 0.14, 0, 0, Math.PI * 2);
    ctx.fill();

    // Body
    ctx.fillStyle = color.hex;
    ctx.beginPath();
    ctx.ellipse(0, 0, rw, rh, 0, 0, Math.PI * 2);
    ctx.fill();

    // Outline
    ctx.strokeStyle = color.dark;
    ctx.lineWidth = 1.2;
    ctx.beginPath();
    ctx.ellipse(0, 0, rw, rh, 0, 0, Math.PI * 2);
    ctx.stroke();

    // Highlight
    ctx.fillStyle = 'rgba(255,255,255,0.22)';
    ctx.beginPath();
    ctx.ellipse(-rw*0.28, -rh*0.32, rw*0.35, rh*0.28, -0.4, 0, Math.PI * 2);
    ctx.fill();

    // Eyes
    const eyeOff = rw * 0.32;
    const eyeY = -rh * 0.08;
    const eww = size * 0.2, ewh = size * 0.26;

    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.ellipse(-eyeOff, eyeY, eww, ewh, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(eyeOff, eyeY, eww, ewh, 0, 0, Math.PI*2);
    ctx.fill();

    // Pupils
    const pp = eww * 0.22;
    ctx.fillStyle = '#111';
    ctx.beginPath();
    ctx.ellipse(-eyeOff+pp, eyeY, eww*0.52, ewh*0.62, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(eyeOff+pp, eyeY, eww*0.52, ewh*0.62, 0, 0, Math.PI*2);
    ctx.fill();

    // Eye shine
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(-eyeOff+pp-eww*0.15, eyeY-ewh*0.25, eww*0.22, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(eyeOff+pp-eww*0.15, eyeY-ewh*0.25, eww*0.22, 0, Math.PI*2);
    ctx.fill();

    // Mouth
    ctx.strokeStyle = color.dark;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(0, rh*0.2, size*0.15, 0.15, Math.PI-0.15);
    ctx.stroke();

    // Cheeks
    ctx.fillStyle = 'rgba(255,120,120,0.25)';
    ctx.beginPath();
    ctx.ellipse(-eyeOff-eww*0.4, eyeY+ewh*0.7, size*0.12, size*0.07, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(eyeOff+eww*0.4, eyeY+ewh*0.7, size*0.12, size*0.07, 0, 0, Math.PI*2);
    ctx.fill();

    // Crown
    if (crown) {
        const cw = rw * 0.5, cy = -rh - cw * 0.5;
        ctx.fillStyle = '#ffd700';
        ctx.beginPath();
        ctx.moveTo(-cw, cy+cw*0.5);
        ctx.lineTo(-cw, cy);
        ctx.lineTo(-cw*0.4, cy+cw*0.3);
        ctx.lineTo(0, cy-cw*0.15);
        ctx.lineTo(cw*0.4, cy+cw*0.3);
        ctx.lineTo(cw, cy);
        ctx.lineTo(cw, cy+cw*0.5);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = '#b8860b';
        ctx.lineWidth = 0.8;
        ctx.stroke();
        // Gem
        ctx.fillStyle = '#ff3333';
        ctx.beginPath();
        ctx.arc(0, cy+cw*0.18, cw*0.12, 0, Math.PI*2);
        ctx.fill();
    }

    ctx.restore();
}

// ‚îÄ‚îÄ Draw NES character ‚îÄ‚îÄ
function drawNESChar(x, y, size, sx, sy, charIdx, crown) {
    const img = nesCharImages[charIdx % nesCharImages.length];
    if (!img || img.width === 0) return;
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(sx, sy);

    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.25)';
    ctx.beginPath();
    ctx.ellipse(0, size * 0.55, size * 0.75, size * 0.14, 0, 0, Math.PI * 2);
    ctx.fill();

    // Character image (centered at bottom)
    const scale = (size * 2) / Math.max(img.width, img.height);
    const w = img.width * scale, h = img.height * scale;
    ctx.drawImage(img, -w / 2, -h + size * 0.3, w, h);

    // Crown (same logic as drawSlime)
    if (crown) {
        const rw = size, rh = size * 0.82;
        const cw = rw * 0.5, cy = -rh - cw * 0.5 - size * 0.3;
        ctx.fillStyle = '#ffd700';
        ctx.beginPath();
        ctx.moveTo(-cw, cy + cw * 0.5);
        ctx.lineTo(-cw, cy);
        ctx.lineTo(-cw * 0.4, cy + cw * 0.3);
        ctx.lineTo(0, cy - cw * 0.15);
        ctx.lineTo(cw * 0.4, cy + cw * 0.3);
        ctx.lineTo(cw, cy);
        ctx.lineTo(cw, cy + cw * 0.5);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = '#b8860b';
        ctx.lineWidth = 0.8;
        ctx.stroke();
        ctx.fillStyle = '#ff3333';
        ctx.beginPath();
        ctx.arc(0, cy + cw * 0.18, cw * 0.12, 0, Math.PI * 2);
        ctx.fill();
    }

    ctx.restore();
}

// ‚îÄ‚îÄ Results ‚îÄ‚îÄ
function showResults() {
    state = 'result';
    if (animId) { cancelAnimationFrame(animId); animId = null; }
    
    // Reset camera transform
    if (canvas) {
        canvas.style.transform = '';
        canvas.style.transformOrigin = '';
    }
    
    showScreen('result-screen');
    playVictoryMusic();  // Play victory music

    // Display finish snapshot
    const snapshotDiv = document.getElementById('finish-snapshot');
    if (finishSnapshot) {
        snapshotDiv.innerHTML = `<img src="${finishSnapshot}" alt="1st place finish moment">`;
    } else {
        snapshotDiv.innerHTML = '';
    }

    const box = document.getElementById('results-list');
    box.innerHTML = '';
    const ranks = ['1ST','2ND','3RD','4TH','5TH','6TH','7TH','8TH'];
    const rcls = ['g','s','b','','','','',''];

    for (let i = 0; i < finishOrder.length; i++) {
        const p = finishOrder[i];
        const row = document.createElement('div');
        row.className = 'res-row' + (i===0?' w':'');
        
        // Build stats string
        const stats = [];
        if (p.boostCount > 0) stats.push(`üöÄ${p.boostCount}`);
        if (p.tripCount > 0) stats.push(`üí•${p.tripCount}`);
        if (p.sleepCount > 0) stats.push(`üí§${p.sleepCount}`);
        const statsHtml = stats.length > 0 
            ? `<div class="res-stats">${stats.map(s => `<span>${s}</span>`).join('')}</div>` 
            : '';
        
        const timeText = p.dnf ? 'DNF' : `${p.finishTime.toFixed(2)}s`;
        row.innerHTML = `
            <span class="res-rank ${rcls[i]}">${ranks[i]}</span>
            <div class="res-dot" style="background:${p.color.hex}"></div>
            <span class="res-name">${p.name}</span>
            ${statsHtml}
            <span class="res-time">${timeText}</span>`;
        box.appendChild(row);
    }
}

// ‚îÄ‚îÄ Download Results ‚îÄ‚îÄ
function downloadResults() {
    const downloadCanvas = document.createElement('canvas');
    const dctx = downloadCanvas.getContext('2d');
    const W = 800, H = 1000;
    downloadCanvas.width = W;
    downloadCanvas.height = H;
    
    // Background
    dctx.fillStyle = '#0a0a1a';
    dctx.fillRect(0, 0, W, H);
    
    let yPos = 40;
    
    // Title
    dctx.font = 'bold 32px "Press Start 2P", monospace';
    dctx.textAlign = 'center';
    dctx.fillStyle = '#ffd700';
    dctx.fillText('SLIME DERBY', W/2, yPos);
    dctx.fillStyle = '#58d854';
    dctx.font = 'bold 24px "Press Start 2P", monospace';
    dctx.fillText('FINISH!', W/2, yPos + 45);
    
    yPos += 90;
    
    // Finish snapshot
    if (finishSnapshot) {
        const img = new Image();
        img.src = finishSnapshot;
        const snapW = 700, snapH = 420;
        const snapX = (W - snapW) / 2;
        dctx.drawImage(img, snapX, yPos, snapW, snapH);
        
        // Border
        dctx.strokeStyle = '#ffd700';
        dctx.lineWidth = 4;
        dctx.strokeRect(snapX, yPos, snapW, snapH);
        
        yPos += snapH + 40;
    }
    
    // Results
    dctx.font = 'bold 20px "Press Start 2P", monospace';
    dctx.fillStyle = '#fff';
    dctx.textAlign = 'left';
    dctx.fillText('RESULTS', 50, yPos);
    yPos += 35;
    
    const ranks = ['1ST','2ND','3RD','4TH','5TH','6TH','7TH','8TH'];
    const rankColors = ['#ffd700','#c0c0c0','#cd7f32','#fff','#fff','#fff','#fff','#fff'];
    
    for (let i = 0; i < finishOrder.length; i++) {
        const p = finishOrder[i];
        const rowH = 50;
        const x = 50;
        
        // Background
        if (i === 0) {
            dctx.fillStyle = 'rgba(255,215,0,0.1)';
            dctx.fillRect(x, yPos, W - 100, rowH);
            dctx.strokeStyle = '#ffd700';
            dctx.lineWidth = 2;
            dctx.strokeRect(x, yPos, W - 100, rowH);
        } else {
            dctx.fillStyle = '#1a1a3a';
            dctx.fillRect(x, yPos, W - 100, rowH);
            dctx.strokeStyle = '#2a2a4a';
            dctx.lineWidth = 1;
            dctx.strokeRect(x, yPos, W - 100, rowH);
        }
        
        // Rank
        dctx.font = 'bold 16px "Press Start 2P", monospace';
        dctx.fillStyle = rankColors[i];
        dctx.textAlign = 'left';
        dctx.fillText(ranks[i], x + 15, yPos + 30);
        
        // Color dot
        dctx.fillStyle = p.color.hex;
        dctx.beginPath();
        dctx.arc(x + 110, yPos + 25, 10, 0, Math.PI * 2);
        dctx.fill();
        
        // Name
        dctx.font = 'bold 14px "Press Start 2P", monospace';
        dctx.fillStyle = '#fff';
        dctx.fillText(p.name, x + 135, yPos + 30);
        
        // Stats
        const stats = [];
        if (p.boostCount > 0) stats.push(`üöÄ${p.boostCount}`);
        if (p.tripCount > 0) stats.push(`üí•${p.tripCount}`);
        if (p.sleepCount > 0) stats.push(`üí§${p.sleepCount}`);
        if (stats.length > 0) {
            dctx.font = '12px "Press Start 2P", monospace';
            dctx.fillStyle = '#888';
            dctx.fillText(stats.join(' '), x + 320, yPos + 30);
        }
        
        // Time
        dctx.font = 'bold 14px "Press Start 2P", monospace';
        dctx.fillStyle = p.dnf ? '#ff6666' : '#aaa';
        dctx.textAlign = 'right';
        dctx.fillText(p.dnf ? 'DNF' : p.finishTime.toFixed(2) + 's', W - 65, yPos + 30);
        
        yPos += rowH + 10;
    }
    
    // Download
    const link = document.createElement('a');
    const timestamp = new Date().toISOString().slice(0,19).replace(/:/g,'-');
    link.download = `slime-derby-${timestamp}.png`;
    link.href = downloadCanvas.toDataURL('image/png');
    link.click();
}

// ‚îÄ‚îÄ Game loop ‚îÄ‚îÄ
function loop() {
    updateRace();
    updateMobileCamera();  // Update camera after race logic
    render();
    animId = requestAnimationFrame(loop);
}

// ‚îÄ‚îÄ LocalStorage ‚îÄ‚îÄ
const LS_KEY = 'slime-derby-setup';

function saveSetup() {
    const names = {};
    document.querySelectorAll('#player-list input[data-idx]').forEach(inp => {
        const v = inp.value.trim();
        if (v) names[inp.dataset.idx] = v;
    });
    const data = {
        count: playerCount,
        useNames: document.getElementById('use-names').checked,
        useNESChars: document.getElementById('use-nes-chars').checked,
        earlyFinish: document.getElementById('early-finish').checked,
        names,
        time: parseInt(document.getElementById('time-input').value) || 10,
    };
    try { localStorage.setItem(LS_KEY, JSON.stringify(data)); } catch(e) {}
}

function loadSetup() {
    try {
        const raw = localStorage.getItem(LS_KEY);
        if (!raw) { buildPlayerInputs(); return; }
        const d = JSON.parse(raw);
        if (d.count != null) {
            playerCount = Math.max(2, Math.min(1000, d.count));
            document.getElementById('player-count').value = playerCount;
        }
        if (d.useNames) {
            document.getElementById('use-names').checked = true;
        }
        if (d.useNESChars) {
            document.getElementById('use-nes-chars').checked = true;
        }
        if (d.earlyFinish !== undefined) {
            document.getElementById('early-finish').checked = d.earlyFinish;
        }
        if (d.time != null) {
            document.getElementById('time-input').value = Math.max(3, Math.min(60, d.time));
        }
        // Build inputs first, then fill saved names
        buildPlayerInputs();
        if (d.names) {
            Object.entries(d.names).forEach(([idx, name]) => {
                const inp = document.querySelector(`#player-list input[data-idx="${idx}"]`);
                if (inp) inp.value = name;
            });
        }
    } catch(e) {}
}

function resetSetup() {
    try { localStorage.removeItem(LS_KEY); } catch(e) {}
    playerCount = 4;
    document.getElementById('player-count').value = 4;
    document.getElementById('use-names').checked = false;
    document.getElementById('use-nes-chars').checked = false;
    document.getElementById('early-finish').checked = true;
    document.getElementById('time-input').value = 10;
    buildPlayerInputs();
    sfxTick();
}

// ‚îÄ‚îÄ Init ‚îÄ‚îÄ
loadSetup();

// ‚îÄ‚îÄ Service Worker ‚îÄ‚îÄ
if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('./sw.js');
}
</script>
</body>
</html>
